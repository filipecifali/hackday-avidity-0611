<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sample-Based Music Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .subtitle {
            opacity: 0.8;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-weight: 600;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .status {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 1.1em;
        }
        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid rgba(255, 193, 7, 0.5);
        }
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid rgba(76, 175, 80, 0.5);
        }
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid rgba(244, 67, 54, 0.5);
        }
        .controls {
            margin-top: 20px;
            display: none;
        }
        .controls.visible {
            display: block;
        }
        .volume-control {
            margin-top: 20px;
        }
        .volume-control input[type="range"] {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 1.6;
        }
        .sample-info {
            margin-top: 15px;
            text-align: left;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 0.95em;
        }
        .sample-info div {
            margin: 5px 0;
        }
        .sample-info strong {
            color: #f093fb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽµ Sample Extender</h1>
        <p class="subtitle">Load a sample, generate a full track</p>

        <button id="generateBtn" onclick="generateMusic()">Generate Music</button>

        <div id="status" class="status">
            Ready! Click to generate music from your samples.
        </div>

        <div id="sampleInfo" class="sample-info" style="display: none;"></div>

        <div id="controls" class="controls">
            <button onclick="stopMusic()" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                Stop Music
            </button>

            <div class="volume-control">
                <label>ðŸ”Š Volume</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="70" oninput="updateVolume(this.value)">
            </div>
        </div>

        <div class="info">
            <strong>How it works:</strong><br>
            Loads your sample â†’ Slices it â†’ Creates 5 layered instruments using the sample audio â†’ Each layer has different rhythm/octave/timing â†’ Generates full track with proper song structure
        </div>
    </div>

    <script>
        let masterVolume = null;
        let isPlaying = false;
        let scheduledEvents = [];
        let instruments = {};
        let samplePlayers = [];

        async function generateMusic() {
            if (isPlaying) {
                showStatus('Music already playing! Stop first.', 'error');
                return;
            }

            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            showStatus('ðŸŽµ Loading samples...', 'loading');

            try {
                // Start Tone.js
                await Tone.start();

                // Load sample manifest
                const response = await fetch('samples/manifest.json');
                if (!response.ok) throw new Error('No samples found! Add samples to samples/ directory.');

                const manifest = await response.json();

                // Pick a random bass sample (or first available sample type)
                let sample = null;
                let sampleType = null;

                if (manifest.bass && manifest.bass.length > 0) {
                    sample = manifest.bass[Math.floor(Math.random() * manifest.bass.length)];
                    sampleType = 'bass';
                } else if (manifest.melody && manifest.melody.length > 0) {
                    sample = manifest.melody[Math.floor(Math.random() * manifest.melody.length)];
                    sampleType = 'melody';
                } else if (manifest.drums && manifest.drums.length > 0) {
                    sample = manifest.drums[Math.floor(Math.random() * manifest.drums.length)];
                    sampleType = 'drums';
                }

                if (!sample) {
                    throw new Error('No samples available in manifest!');
                }

                showStatus(`ðŸŽ¯ Analyzing: ${sample.file}`, 'loading');

                // Display sample info
                displaySampleInfo(sample, sampleType);

                // Set tempo
                const bpm = sample.bpm || 120;
                Tone.Transport.bpm.value = bpm;

                // Create master volume
                masterVolume = new Tone.Volume(-10).toDestination();

                // Load the sample
                const samplePlayer = new Tone.Player({
                    url: `samples/${sampleType}/${sample.file}`,
                    loop: true,
                    volume: -3
                }).connect(masterVolume);

                await Tone.loaded();
                samplePlayers.push(samplePlayer);

                showStatus('ðŸŽ¼ Generating extended track...', 'loading');

                // Generate extended music based on sample
                await extendSample(sample, samplePlayer, bpm, sampleType);

                // Start playback
                Tone.Transport.start();
                isPlaying = true;

                showStatus(`âœ… Playing! Extended to full track (${Tone.Transport.seconds}s)`, 'success');
                document.getElementById('controls').classList.add('visible');

            } catch (error) {
                console.error('Error:', error);
                showStatus(`âŒ Error: ${error.message}`, 'error');
                btn.disabled = false;
            }
        }

        async function extendSample(sample, samplePlayer, bpm, sampleType) {
            // Extract sample metadata
            const key = sample.key || 'C';
            const mode = sample.mode || 'minor';
            const notePattern = sample.notePattern || ['C2', 'Eb2', 'G2', 'C3'];
            const groove = sample.groove || { swing: 0.5, slides: false };

            // Build scale based on key/mode
            const scale = buildScale(key, mode);

            // Create sample-based instruments (using sliced sample audio)
            const sampleUrl = `samples/${sampleType}/${sample.file}`;
            await createSampleBasedInstruments(sampleUrl, key);

            // Structure: intro (sample) â†’ verse â†’ chorus â†’ verse â†’ bridge â†’ outro
            const sections = [
                { name: 'intro', bars: 4, useOriginal: true, intensity: 0.4 },
                { name: 'verse1', bars: 8, useOriginal: false, intensity: 0.6 },
                { name: 'chorus1', bars: 8, useOriginal: false, intensity: 1.0 },
                { name: 'verse2', bars: 8, useOriginal: false, intensity: 0.7 },
                { name: 'bridge', bars: 4, useOriginal: false, intensity: 0.8 },
                { name: 'chorus2', bars: 8, useOriginal: false, intensity: 1.0 },
                { name: 'outro', bars: 4, useOriginal: true, intensity: 0.3 }
            ];

            let currentTime = 0;
            const barDuration = (60 / bpm) * 4; // 4 beats per bar

            sections.forEach((section, idx) => {
                const startTime = currentTime;
                const duration = section.bars * barDuration;
                const endTime = startTime + duration;

                console.log(`ðŸŽµ Section: ${section.name} (${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s)`);

                // Start/stop original sample based on section
                if (section.useOriginal) {
                    scheduledEvents.push(Tone.Transport.schedule((time) => {
                        samplePlayer.volume.linearRampTo(-3, 1, time);
                        if (samplePlayer.state !== 'started') {
                            samplePlayer.start(time);
                        }
                    }, startTime));
                } else {
                    scheduledEvents.push(Tone.Transport.schedule((time) => {
                        samplePlayer.volume.linearRampTo(-20, 2, time); // Fade out
                    }, startTime));
                }

                // LAYER 1: Bass line (original rhythm, sliced sample)
                if (instruments.bassLayer && notePattern) {
                    generateBassLayer(notePattern, startTime, duration, section.intensity, groove, idx);
                }

                // LAYER 2: Melody (different rhythm, higher octave, sliced sample)
                if (instruments.melodyLayer && notePattern) {
                    generateMelodyLayer(notePattern, scale, startTime, duration, section.intensity, idx);
                }

                // LAYER 3: Harmony/Chords (sustained, sliced sample)
                if (instruments.harmonyLayer && section.intensity > 0.5) {
                    generateHarmonyLayer(scale, startTime, duration, section.intensity, idx);
                }

                // LAYER 4: Drums (synthesized for rhythm backbone)
                if (instruments.kick) {
                    generateDrumSection(startTime, duration, section.intensity, bpm);
                }

                // LAYER 5: Percussion fills (sample-based, occasional)
                if (instruments.percLayer && section.intensity > 0.7) {
                    generatePercussionLayer(notePattern, startTime, duration, section.intensity);
                }

                currentTime = endTime;
            });

            console.log(`âœ… Total track: ${currentTime.toFixed(1)}s with 5 layered instruments`);
        }

        function buildScale(key, mode) {
            const rootMidi = 60 + ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].indexOf(key);
            const intervals = mode === 'minor' ? [0, 2, 3, 5, 7, 8, 10] : [0, 2, 4, 5, 7, 9, 11];

            const scale = [];
            for (let octave = 2; octave <= 5; octave++) {
                intervals.forEach(interval => {
                    const midi = rootMidi - 24 + (octave - 2) * 12 + interval;
                    scale.push(Tone.Frequency(midi, 'midi').toNote());
                });
            }
            return scale;
        }

        async function createSampleBasedInstruments(sampleUrl, rootKey) {
            console.log('ðŸŽ¹ Creating sample-based instruments using original sample audio...');

            // Create a note mapping for the sampler (map sample to multiple notes)
            // This will pitch-shift the sample to play different notes
            const noteMap = {};
            const notes = ['C2', 'D2', 'E2', 'F2', 'G2', 'A2', 'B2', 'C3', 'D3', 'E3', 'F3', 'G3'];

            // LAYER 1: Bass Layer (uses sliced sample for bass notes)
            instruments.bassLayer = new Tone.Sampler({
                urls: { [rootKey + '2']: sampleUrl },
                baseUrl: '',
                volume: -5,
                attack: 0.01,
                release: 0.4
            }).connect(masterVolume);

            // LAYER 2: Melody Layer (same sample, different envelope for melody)
            instruments.melodyLayer = new Tone.Sampler({
                urls: { [rootKey + '3']: sampleUrl },
                baseUrl: '',
                volume: -8,
                attack: 0.02,
                release: 0.6
            }).connect(masterVolume);

            // LAYER 3: Harmony Layer (same sample, longer sustain for chords)
            instruments.harmonyLayer = new Tone.Sampler({
                urls: { [rootKey + '3']: sampleUrl },
                baseUrl: '',
                volume: -12,
                attack: 0.5,
                release: 2
            }).connect(masterVolume);

            // LAYER 4: Percussion Layer (same sample, short/staccato)
            instruments.percLayer = new Tone.Sampler({
                urls: { [rootKey + '4']: sampleUrl },
                baseUrl: '',
                volume: -10,
                attack: 0.001,
                release: 0.1
            }).connect(masterVolume);

            // LAYER 5: Drums (keep synthesized)
            instruments.kick = new Tone.MembraneSynth({
                pitchDecay: 0.05, octaves: 10,
                oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 },
                volume: -5
            }).connect(masterVolume);

            instruments.snare = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0 },
                volume: -7
            }).connect(masterVolume);

            instruments.hihat = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
                harmonicity: 5.1, modulationIndex: 32,
                resonance: 4000, octaves: 1.5,
                volume: -17
            }).connect(masterVolume);

            // Wait for samplers to load
            await Tone.loaded();
            console.log('âœ… All sample-based layers loaded!');
        }

        function generateBassLayer(pattern, startTime, duration, intensity, groove, sectionIdx) {
            // LAYER 1: Bass - Original rhythm, low notes, sample-based
            const swing = groove.swing || 0.5;
            const beatsPerNote = 0.5; // 8th notes

            // Create variations
            const variations = [];
            const repeatCount = Math.ceil(duration / (pattern.length * beatsPerNote));

            for (let r = 0; r < repeatCount; r++) {
                pattern.forEach((note, i) => {
                    if (note === 'rest') {
                        variations.push('rest');
                    } else {
                        // Occasionally vary (more in later sections)
                        const random = Math.random();
                        if (random < 0.1 * intensity && sectionIdx > 1) {
                            // Transpose octave
                            try {
                                const midi = Tone.Frequency(note).toMidi();
                                variations.push(Tone.Frequency(midi + 12, 'midi').toNote());
                            } catch {
                                variations.push(note);
                            }
                        } else {
                            variations.push(note);
                        }
                    }
                });
            }

            // Schedule notes using sample-based instrument
            variations.forEach((note, i) => {
                if (note === 'rest') return;

                const baseTime = i * beatsPerNote;
                const swingOffset = (i % 2 === 1) ? swing * 0.1 : 0;
                const noteTime = startTime + baseTime + swingOffset;

                if (noteTime < startTime + duration) {
                    scheduledEvents.push(Tone.Transport.schedule((time) => {
                        // Use sliced sample for bass notes
                        instruments.bassLayer.triggerAttackRelease(note, '8n', time, intensity * 0.9);
                    }, noteTime));
                }
            });
        }

        function generateMelodyLayer(pattern, scale, startTime, duration, intensity, sectionIdx) {
            // LAYER 2: Melody - Different rhythm, higher octave, sample-based
            if (intensity < 0.6) return; // Only in higher energy sections

            // Create melody pattern (higher octave, sparser rhythm)
            const melodyPattern = [];
            pattern.forEach((note, i) => {
                if (note === 'rest' || Math.random() > intensity * 0.7) {
                    melodyPattern.push('rest');
                } else {
                    try {
                        const midi = Tone.Frequency(note).toMidi() + 12; // Octave up
                        melodyPattern.push(Tone.Frequency(midi, 'midi').toNote());
                    } catch {
                        melodyPattern.push(scale[Math.floor(Math.random() * scale.length)]);
                    }
                }
            });

            // Different rhythm - quarter notes instead of eighth notes
            const beatsPerNote = 1.0;
            const repeatCount = Math.ceil(duration / (melodyPattern.length * beatsPerNote));

            for (let r = 0; r < repeatCount; r++) {
                melodyPattern.forEach((note, i) => {
                    if (note === 'rest') return;

                    const noteTime = startTime + (r * melodyPattern.length + i) * beatsPerNote;
                    if (noteTime < startTime + duration) {
                        scheduledEvents.push(Tone.Transport.schedule((time) => {
                            instruments.melodyLayer.triggerAttackRelease(note, '4n', time, intensity * 0.8);
                        }, noteTime));
                    }
                });
            }
        }

        function generateHarmonyLayer(scale, startTime, duration, intensity, sectionIdx) {
            // LAYER 3: Harmony - Sustained chords, sample-based
            // Build chords from scale
            const chords = [
                [scale[0], scale[2], scale[4]],   // i
                [scale[3], scale[5], scale[7]],   // iv
                [scale[4], scale[6], scale[8]],   // v
                [scale[2], scale[4], scale[6]]    // iii
            ];

            // Different rhythm - whole notes (4 bars)
            const barsPerChord = 2;
            const beatDuration = 60 / Tone.Transport.bpm.value;
            const chordDuration = barsPerChord * 4 * beatDuration;

            chords.forEach((chord, i) => {
                const chordTime = startTime + i * chordDuration;
                if (chordTime < startTime + duration) {
                    scheduledEvents.push(Tone.Transport.schedule((time) => {
                        // Play each note of chord with sample
                        chord.forEach((note, idx) => {
                            setTimeout(() => {
                                instruments.harmonyLayer.triggerAttackRelease(note, chordDuration, time, intensity * 0.4);
                            }, idx * 50); // Slight stagger for richer sound
                        });
                    }, chordTime));
                }
            });
        }

        function generatePercussionLayer(pattern, startTime, duration, intensity) {
            // LAYER 5: Percussion fills - Occasional staccato hits from sample
            const beatsPerNote = 0.25; // 16th notes
            const fillInterval = 8; // Every 8 beats

            for (let t = 0; t < duration; t += fillInterval) {
                if (Math.random() > 0.6) { // 40% chance of fill
                    const fillNote = pattern[Math.floor(Math.random() * pattern.length)];
                    if (fillNote !== 'rest') {
                        try {
                            const midi = Tone.Frequency(fillNote).toMidi() + 24; // 2 octaves up
                            const highNote = Tone.Frequency(midi, 'midi').toNote();

                            // Quick triplet fill
                            for (let i = 0; i < 3; i++) {
                                scheduledEvents.push(Tone.Transport.schedule((time) => {
                                    instruments.percLayer.triggerAttackRelease(highNote, '32n', time, intensity * 0.6);
                                }, startTime + t + i * 0.1));
                            }
                        } catch (e) {
                            // Skip if note conversion fails
                        }
                    }
                }
            }
        }

        function generateDrumSection(startTime, duration, intensity, bpm) {
            const kickInterval = 1; // Every beat
            const snareInterval = 2; // Every 2 beats (backbeat)
            const hihatInterval = intensity > 0.7 ? 0.25 : 0.5;

            // Kick
            for (let t = 0; t < duration; t += kickInterval) {
                scheduledEvents.push(Tone.Transport.schedule((time) => {
                    instruments.kick.triggerAttackRelease('C1', '8n', time);
                }, startTime + t));
            }

            // Snare on 2 and 4
            for (let t = 1; t < duration; t += snareInterval) {
                scheduledEvents.push(Tone.Transport.schedule((time) => {
                    instruments.snare.triggerAttackRelease('8n', time);
                }, startTime + t));
            }

            // Hi-hats
            for (let t = 0; t < duration; t += hihatInterval) {
                scheduledEvents.push(Tone.Transport.schedule((time) => {
                    instruments.hihat.triggerAttackRelease('32n', time, intensity * 0.6);
                }, startTime + t));
            }
        }


        function displaySampleInfo(sample, type) {
            const info = document.getElementById('sampleInfo');
            info.style.display = 'block';
            info.innerHTML = `
                <div><strong>Sample:</strong> ${sample.file}</div>
                <div><strong>Type:</strong> ${type}</div>
                <div><strong>BPM:</strong> ${sample.bpm || 'Unknown'}</div>
                <div><strong>Key:</strong> ${sample.key || 'Unknown'} ${sample.mode || ''}</div>
                <div><strong>Style:</strong> ${sample.style || 'N/A'}</div>
                ${sample.notePattern ? `<div><strong>Pattern:</strong> ${sample.notePattern.join(', ')}</div>` : ''}
            `;
        }

        function stopMusic() {
            Tone.Transport.stop();
            Tone.Transport.cancel(0);

            // Clean up scheduled events
            scheduledEvents.forEach(event => event.dispose?.());
            scheduledEvents = [];

            // Stop and dispose players
            samplePlayers.forEach(player => {
                player.stop();
                player.dispose();
            });
            samplePlayers = [];

            // Dispose instruments
            Object.values(instruments).forEach(inst => inst?.dispose?.());
            instruments = {};

            if (masterVolume) {
                masterVolume.dispose();
                masterVolume = null;
            }

            isPlaying = false;
            document.getElementById('controls').classList.remove('visible');
            document.getElementById('generateBtn').disabled = false;
            showStatus('Music stopped. Ready to generate again!', 'success');
        }

        function updateVolume(value) {
            if (masterVolume) {
                const db = (parseFloat(value) / 100) * 10 - 10;
                masterVolume.volume.value = db;
            }
        }

        function showStatus(message, type = '') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }
    </script>
</body>
</html>
